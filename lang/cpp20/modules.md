# モジュール
* cpp20[meta cpp]

## 概要
C++20では、インクルードに代わる新たな仕組みとしてモジュールが導入された。

C++20では、プリプロセッサを用いずにプログラムを分割することができる：

```cpp
// P1103R3より引用

// a.cpp
export module A; // モジュールAのインターフェース

int foo() { return 1; } // エクスポートしていない関数foo
export int bar();       // エクスポートしている関数bar

// a-impl.cpp
module A; // モジュールAの実装

int bar() {
  return foo() + 1; // OK: fooはエクスポートしていないが、モジュールAの中では見える。
}

// unrelated.cpp
import A;

int main() {
  bar(); // OK: barはAからエクスポートされているので見える
  foo(); // エラー: fooはモジュールAの外では見えない
}
```
* P1103R3[link http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf]

## 仕様

### モジュール宣言

モジュール宣言の構文は以下のようになる：

```
export(opt) module モジュール名 属性(opt);
```

- モジュール宣言は翻訳単位あたり1回だけ、原則として翻訳単位の先頭に記述する。
- モジュール宣言を含む翻訳単位をモジュールユニットという。
    - `export`がある場合をモジュールインターフェースユニット、ない場合をモジュール実装ユニットと呼ぶ。
    - あるモジュールについて、モジュールインターフェースユニットがただ1つ存在しなければならない。モジュールの実装は好きなだけ存在できる。
    - モジュール実装ユニットはモジュールインターフェースユニットを暗黙的にインポートする。
- モジュール名は、識別子または識別子をドットで繋いだもの(例えば、`foo`や`std.core`)である。

```cpp
export module foo; // fooのモジュールインターフェースユニット
```

```cpp
module foo; // fooのモジュール実装ユニット
```

```cpp
module foo.bar; // foo.barのモジュール実装ユニット
```

```cpp
export module bar [[deprecated]]; // 属性
```

#### プライベートモジュールフラグメント

プライベートモジュールフラグメントは、1ファイルでモジュールを定義しつつインターフェースと実装を分離するための機能である。

```cpp
export module foo;
// モジュールのインターフェース
module :private;
// プライベートモジュールフラグメント
```

プライベートモジュールフラグメントを記述する場合、そのモジュールは翻訳単位(必然的にモジュールインターフェースユニット)を1つしか持つことができない。


#### グローバルモジュール

C++20では、名前のあるモジュールに属していない宣言はグローバルモジュールに属している。

グローバルモジュールの性質は以下の通り。

* 名前を持たず、インポートすることはできない。
* 宣言をエクスポートすることはできない。
* モジュールインターフェースユニットを持つことはできない。

### エクスポート

宣言の前に`export`キーワードを付加することでその対象をエクスポートできる。
モジュールをインポートするとエクスポートした宣言が見える(名前探索の候補に挙がる)ようになる。

```cpp
export int x; // 変数のエクスポート
export class x{ /*...*/ }; // クラスのエクスポート
export namespace x { /*...*/ } // 名前空間のエクスポート
export template<class T> foobar(); // 関数テンプレートのエクスポート
```

また、波カッコに`export`をつけることで、その中の宣言をまとめてエクスポートできる。この波カッコはスコープを作らない。

```cpp
export {
  void f();
}
```

エクスポート宣言はモジュールインターフェースユニットの中でのみ行える。ただし、以下の場所では不可。

* グローバルモジュールフラグメントの中
* プライベートモジュールフラグメントの中

エクスポート宣言は必ず新たな名前をエクスポートしなければならない。

* `export`を付けた宣言が新たな名前を宣言していない場合は、エラーとなる。
* 内部リンケージを持つ名前をエクスポートすると、エラーとなる。

```cpp
// P1103R3より引用
export module M;
export namespace {}       // エラー: 新たな名前を宣言していない
export namespace {
  int a1;                 // エラー: 内部リンケージを持つ名前はエクスポートできない
}
namespace {
  export int a2;          // エラー: 内部リンケージを持つ名前はエクスポートできない
}
export static int b;      // エラー: 明示的にstaticで宣言されている名前はエクスポートできない
export int f();           // OK
export namespace N { }    // OK
export using namespace N; // エラー: 新たな名前を宣言していない
```
* P1103R3[link http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf]

#### モジュールリンケージ

C++20では、新たにモジュールリンケージが追加された。

* 名前のあるモジュールに属していてエクスポートしていない名前は、モジュールリンケージを持つ。
    * エクスポートしている名前は外部リンケージを持つ。
* モジュールリンケージを持つ名前は、同一モジュール内で参照できる。

### インポート

モジュールインポート宣言は次のようになる：

```cpp
import lib; // libのインポート
```

モジュールインポート宣言は、モジュールのインターフェースユニットをインポートする。

インポートした翻訳単位中の宣言について、

- すべての宣言は到達可能となる。
- エクスポートしている宣言は見える(名前探索の候補に挙がる)ようになる。

マクロや`using namespace`は取り込まれない。ヘッダーファイル中での `using namespace` はしばしば避けられるが、モジュールでは問題なく使うことができる。

#### 再エクスポート

インポート宣言もエクスポートできる。これを再エクスポートという。

```cpp
export import lib; // libの再エクスポート
```

再エクスポートすると、インポートで見えるようになった宣言をそのままエクスポートしたことになる。

#### インターフェース依存

翻訳単位がモジュールユニットUに**インターフェース依存**(interface dependency)を持つとは、次のことをいう：

- Uをインポートするモジュールインポート宣言か、Uを暗黙的にインポートするモジュール宣言を含む
- または、Uにインターフェース依存を持つモジュールユニットに対してインターフェース依存を持つ(推移律)

翻訳単位は、自分自身に対してインターフェース依存を持ってはならない(インターフェース依存関係は循環しない)。

#### 到達可能性

C++20では、翻訳単位と宣言に対して到達可能という用語を使うようになった。

翻訳単位Uがプログラムの点Pから**必然的に到達可能**(necessarily reachable) とは、次のことをいう：

- Uがモジュールインターフェースユニットであり、点Pを含む翻訳単位が点Pに先立ってUにインターフェース依存を持っている
- または、点Pを含む翻訳単位が点Pに先立ってUをインポートしている

必然的に到達可能な翻訳単位は、**到達可能**(reachable)である。その他のインターフェース依存を持つ翻訳単位が到達可能となるかは、未規定である。
(推移的にインターフェース依存を持つモジュール実装パーティションなどが該当する)

宣言Dが点Pから到達可能あるいは必然的に到達可能とは、次のことをいう

- DがPと同じ翻訳単位にあり、Pに先立って宣言されている
- または、DがPから到達可能あるいは必然的に到達可能な翻訳単位にあって、破棄(discard)されておらず、プライベートモジュールフラグメント内にもない

C++20までは到達可能という用語はなかったが、前者の条件を満たす宣言だけが参照できていた。
宣言の意味論的な性質(semantic property)を使用するには、宣言が到達可能でなければならない。

例えば、クラス定義はクラスの完全性という性質を持っている。クラス定義が到達可能であるときそのクラスは完全である。

### モジュールパーティション

モジュールは分割することができる。分割したモジュールをモジュールパーティションという。

モジュールパーティションを宣言する構文は以下のようになる：

```
export(opt) module モジュール名:モジュールパーティション名 属性(opt);
```

- モジュールパーティション名の書式は、モジュール名と同じである。
- `export` がある場合をモジュールインターフェースパーティション、ない場合をモジュール実装パーティションという。

```cpp
export module lib:part; // libモジュールのモジュールインターフェースパーティションpart
```

```cpp
module lib:internal; // libモジュールのモジュール実装パーティションinternal
```

モジュールパーティションは基本的に別のモジュールと考えてよいが、以下の点で異なる：

- 主となるモジュールが異なる場合はインポートできない。
    - 外部へ公開するには、モジュールインターフェースから再エクスポートする。
    - モジュールの利用者にパーティションの存在を意識させてはいけない。
- インポート宣言にはモジュールパーティション名だけを書く。
- インポートするとエクスポートしていない宣言も見えるようになる。
    - ただし、再エクスポートはできない。

主となるモジュールのインターフェースとパーティションを区別する場合は、プライマリーモジュールインターフェースユニットという事がある。

```cpp
// P1103R3より引用
// 翻訳単位1
export module A;
export import :Foo;
export int baz();

// 翻訳単位2
export module A:Foo;
import :Internals;
export int foo() { return 2 * (bar() + 1); }

// 翻訳単位3
module A:Internals;
int bar();

// 翻訳単位4
module A;
import :Internals;
int bar() { return baz() - 10; }
int baz() { return 30; }
```
* P1103R3[link http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf]

このモジュールAは4つの翻訳単位からなる。上から順に、

1. (プライマリー)モジュールインターフェースユニット
2. モジュールインターフェースパーティション `:Foo`
3. モジュール実装パーティション `:Internals`
4. モジュール実装ユニット


### ODRの緩和

C++20では、複数の定義があっても必然的に到達可能でなければODR違反とならない。

```cpp
// a.cpp
export module A;

export void foo(){}
```

```cpp
// b.cpp
export module B;

export void foo(){}
```

```cpp
import A;

int main()
{
  foo();
}
```

このプログラムでは、関数`foo`をモジュールA,Bで2回定義しているが、モジュールA,Bを同時にインポートしていないのでODR違反とならない。

一方、同じトークン列であれば再定義しても良いというODRの例外は、その定義が名前のあるモジュールに属する場合は適用されない。

この例外はヘッダーファイルにクラス定義などを書いてインクルードした際にODR違反にならないための規定である。
モジュールを定義する場合はヘッダーファイルは使わないから、実質的な影響はない。

## 後方互換性のための機能

### グローバルモジュールフラグメント

モジュール宣言の前にグローバルモジュールの実装を書くことができる。これをグローバルモジュールフラグメントという。

グローバルモジュールフラグメントにはプリプロセッサディレクティブのみ記述できる。
翻訳フェーズ4以前の段階でプリプロセッサディレクティブ以外の記述がある場合は、エラーとなる。

この機能は、モジュールのインターフェースへ影響を与えずにインクルードをするために用意された。

```cpp
module;             // グローバルモジュールフラグメントの宣言

#include <iostream> // <iostream>中の宣言はモジュールfooに含まれない。

export module foo;

#include "lib.h"    // "lib.h"中の宣言がモジュールfooに含まれてしまう(モジュールリンケージを持ってしまう)。

void f() {
  std::cout << "foo" << std::endl;
}
// 
```

### ヘッダーユニット

ヘッダーユニットは、ヘッダーファイルをモジュールとしてインポートする機能である。
ヘッダーファイル内の宣言が見えるようになり、通常のモジュールとは異なりマクロも引き継がれる。

```cpp
import <foo.h>; // foo.hをヘッダーユニットとしてインポート
```

ヘッダーユニットは再エクスポートできる。

```cpp
// lib.h

inline int f(){ return NUM; }

#define NUM 1000

```

```cpp
// lib_mod.cpp
// lib.h中の宣言をすべてエクスポートするモジュールlib
export module lib;
export import "lib.h";

```

```cpp
// main.cpp
import lib;

int main() {
  1 + f(); // OK
  1 + NUM; // エラー: マクロは再エクスポートしても引き継がれない
}
```

ヘッダーユニットをインポートすると以下のことが起こる。

* ヘッダーファイルをプリプロセスし、フェーズ4終了時点で定義されていたマクロをインポート宣言の直後で再定義する。
* ヘッダーファイルをフェーズ7までコンパイルし、その翻訳単位(ヘッダーユニット)をインポートする。
    * 内部リンケージを持たない名前は暗黙的にエクスポートされる。
    * ヘッダーユニットはモジュール宣言を持てない。ヘッダーユニット内の宣言はグローバルモジュールに属する。

```cpp
// P1103R3より引用
// a.h
#define X 123 // #1
#define Y 45  // #2
#define Z a   // #3
#undef  X      // a.hではここで#1が無効になる

// b.h
import "a.h"; // b.hではここで#1, #2, #3が定義され、#1が無効になる
#define X 456 // OK: #1で定義したXはすでに無効
#define Y 6   // エラー: #2で定義したYが有効

// c.h
#define Y 45  // #4
#define Z c   // #5

// d.h
import "a.h"; // d.hではここで#1, #2, #3が定義され、#1が無効になる
import "c.h"; // d.hではここで#4, #5が定義される
int a = Y;    // OK: #4は#2と同じ
int c = Z;    // エラー: #5は#3を異なる値で再定義している
```
* P1103R3[link http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf]

インポートできるヘッダーの集合をインポータブルヘッダーという。何がインポータブルヘッダーかは、処理系定義である。

C++20では、インポータブルヘッダーに対する `#include` はヘッダーユニットのインポートに置き換えられる。

## ビルド

プログラムのビルドは規格の範囲外なので、ここでは一般論を述べる。

モジュールをコンパイルすると、何らかの中間表現(コンパイル済みモジュール)が保存される。

- テンプレートはテンプレートのまま（実体化することなく）エクスポートできるので、中間表現は機械語ではなく、いわゆるプリコンパイルドヘッダーと似たようなものにならざるを得ない。
- モジュールAをインポートするプログラムをコンパイルするには、モジュールAのコンパイル済みモジュールが存在しなければならない。
- モジュールAをインポートするプログラムをリンクするには、モジュールAに関するモジュールユニットから生成されるオブジェクトファイル、ライブラリなどを別途リンクしなければならない。

## この機能が必要になった背景・経緯

プリプロセッサによるインクルードは、ヘッダーファイルの内容をその場に展開する。
これには次のような問題が指摘されてきた。

1. コンパイル時間が長くなる
    - ヘッダーファイルの内容が再帰的に展開され、プログラムが長くなる（Hello worldだけでも数万行に達する）
    - さらに、展開が翻訳単位ごとに行われるので、全体で見ると同じヘッダーファイルが何度も解析される
2. プリプロセッサの状態により、インクルードの結果が変わってしまう
    - インクルードの順番によってエラーが起きることがあった。
3. ヘッダーファイル内の記述の影響を受けすぎる
    - 影響が大きいため、ヘッダーファイル内に書くことがためらわれる記述があった。
    - `using namespace`やマクロ(例えばWindowsにおける`max`)など。

モジュールは、以上のような問題のないプログラム分割の仕組みとして導入された。

## 参照
- [P1103R3 Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf)
